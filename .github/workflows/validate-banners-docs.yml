name: CI — Validate banners & docstrings (soft)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Validate banners & docstrings (soft rules)
        run: |
          python - <<'PY'
          from __future__ import annotations
          """
          validate_docstrings_soft.py — Vérification non-brisante
          - ÉCHEC (exit != 0) seulement si:
              * SyntaxError dans un .py
              * absence de docstring module ET absence de bannière de commentaires
          - Alerte (print) si fonctions/classes publiques sans docstring (NE FAIT PAS ÉCHOUER)
          """
          import ast, sys, os
          from pathlib import Path

          IGNORED_DIRS = {".git","__pycache__",".venv","venv",".env",".mypy_cache",".pytest_cache","node_modules",".idea",".vscode",".arch_runs",".archcode/archive"}

          def iter_py_files(root: Path):
              for p in sorted(root.rglob("*.py")):
                  try:
                      rel = p.relative_to(root)
                  except Exception:
                      continue
                  if any(seg in IGNORED_DIRS for seg in rel.parts):
                      continue
                  yield p

          def banner_in_comments(text: str) -> bool:
              lines = text.splitlines()
              comment_lines = []
              for ln in lines:
                  s = ln.strip()
                  if not s:
                      if comment_lines:
                          break
                      else:
                          continue
                  if s.startswith("#!"):
                      continue
                  if s.startswith("# -*-") or s.startswith("# coding:"):
                      continue
                  if s.startswith("#"):
                      comment_lines.append(s.lstrip("# ").rstrip())
                      continue
                  break
              return len(comment_lines) > 0

          root = Path.cwd()
          failures = []   # conditions fatales
          alerts = []     # conditions non-fatales (warnings)
          total = 0

          for py in iter_py_files(root):
              total += 1
              text = py.read_text(encoding="utf-8", errors="ignore")
              try:
                  mod = ast.parse(text)
              except SyntaxError as e:
                  failures.append(f"{py}: SyntaxError: {e}")
                  continue

              # module docstring or banner? (fatal if none)
              mod_doc = ast.get_docstring(mod)
              has_banner = bool(mod_doc) or banner_in_comments(text)
              if not has_banner:
                  failures.append(f"{py}: missing module docstring or banner")
                  # continue scanning to show more issues

              # check public defs/classes for docstrings (non-fatal: alert only)
              for node in mod.body:
                  if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                      name = getattr(node, "name", "<anon>")
                      if name.startswith("_"):
                          continue
                      ds = ast.get_docstring(node)
                      if not ds:
                          alerts.append(f"{py}: public symbol '{name}' missing docstring")

          # Print summary
          if failures:
              print("=== Validation CRITIQUE — problèmes détectés ===", file=sys.stderr)
              for f in failures:
                  print(f"- {f}", file=sys.stderr)
              print(f"\nTotal fichiers scannés: {total}; problèmes critiques: {len(failures)}", file=sys.stderr)
              # also print alerts for context
              if alerts:
                  print("\n=== Alerte(s) non critiques (docstrings manquantes) ===", file=sys.stderr)
                  for a in alerts[:200]:
                      print(f"- {a}", file=sys.stderr)
              sys.exit(2)

          # No failures -> success, but show alerts if any
          if alerts:
              print("=== Validation OK (pas de problèmes critiques). Alerte(s) détectées: ===")
              for a in alerts:
                  print(f"- {a}")
              print(f"\nTotal fichiers scannés: {total}; alertes: {len(alerts)}")
              sys.exit(0)
          else:
              print(f"OK — {total} fichiers Python scannés. Bannières/docstrings module présentes.")
              sys.exit(0)
          PY
