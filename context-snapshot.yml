name: Context Snapshot (mARCHCode)

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  snapshot:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install pyyaml

      - name: Create scripts dir
        run: mkdir -p scripts .archcode

      - name: Add snapshot + tiddler scripts
        shell: bash
        run: |
          cat > scripts/context_snapshot.py <<-'PY'
          # (place here your existing context_snapshot.py code - or use the version we tested)
          from __future__ import annotations

          import ast, sys, os, platform, yaml
          from dataclasses import dataclass
          from pathlib import Path
          from typing import Any, Dict, List, Optional, Union
          from datetime import datetime

          IGNORED_DIRS = {".git","__pycache__",".venv","venv",".env",".mypy_cache",".pytest_cache","node_modules",".idea",".vscode"}
          DEFAULT_OUT = ".archcode/context_snapshot.yaml"

          class _LiteralDumper(yaml.SafeDumper): pass
          def _repr_str(dumper: yaml.Dumper, data: str):
              style = "|" if ("\n" in data) else None
              return dumper.represent_scalar("tag:yaml.org,2002:str", data, style=style)
          _LiteralDumper.add_representer(str, _repr_str)

          def iter_files(root: Path) -> List[Path]:
              files: List[Path] = []
              for p in sorted(root.rglob("*")):
                  try:
                      rel = p.relative_to(root)
                  except Exception:
                      continue
                  if any(seg in IGNORED_DIRS for seg in rel.parts):
                      continue
                  if p.is_file():
                      files.append(p)
              return files

          def ascii_tree(root: Path) -> str:
              lines = [str(root.resolve())]
              def kids(d):
                  out=[]
                  try:
                      it = sorted(d.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower()))
                  except Exception:
                      return out
                  for p in it:
                      try:
                          rel = p.relative_to(root)
                      except Exception:
                          continue
                      if any(seg in IGNORED_DIRS for seg in rel.parts):
                          continue
                      out.append(p)
                  return out
              def walk(d, prefix=""):
                  ch = kids(d)
                  for i,k in enumerate(ch):
                      joint = "└── " if i==len(ch)-1 else "├── "
                      lines.append(f"{prefix}{joint}{k.name}")
                      if k.is_dir():
                          ext = "    " if i==len(ch)-1 else "│   "
                          walk(k, prefix+ext)
              walk(root); return "\n".join(lines)

          @dataclass
          class RouteInfo:
              framework: str
              method: Optional[Union[str,List[str]]] = None
              path: Optional[str] = None

          @dataclass
          class DefInfo:
              qualname: str; name: str; lineno: int
              params: List[str]; decorators: List[str]
              docstring: Optional[str]; route: Optional[RouteInfo]

          def _first_toplevel_string_after_imports(module: ast.Module) -> Optional[str]:
              for node in module.body:
                  if isinstance(node, ast.Expr) and isinstance(getattr(node,"value",None),ast.Constant):
                      if isinstance(node.value.value,str): return node.value.value
              return None

          def _decorator_to_text(dec: ast.AST) -> str:
              def name_of(n):
                  if isinstance(n, ast.Name): return n.id
                  if isinstance(n, ast.Attribute): return f"{name_of(n.value)}.{n.attr}"
                  if isinstance(n, ast.Call): return name_of(n.func)
                  return n.__class__.__name__
              return name_of(dec)

          def _literal_str(node):
              if isinstance(node, ast.Constant) and isinstance(node.value,str): return node.value
              return None

          def _literal_methods_from_kwargs(call: ast.Call):
              for kw in call.keywords:
                  if kw.arg in {"methods","method"}:
                      v=kw.value
                      if isinstance(v,ast.List):
                          out=[e.value.upper() for e in v.elts if isinstance(e,ast.Constant) and isinstance(e.value,str)]
                          return out or None
                      if isinstance(v,ast.Constant) and isinstance(v.value,str):
                          return [v.value.upper()]
              return None

          def _detect_route(dec: ast.AST):
              if isinstance(dec,ast.Call) and isinstance(dec.func,ast.Attribute):
                  attr = dec.func.attr.lower()
                  if attr in {"get","post","put","delete","patch","options","head"}:
                      return RouteInfo("fastapi", attr.upper(), _literal_str(dec.args[0]) if dec.args else None)
                  if attr=="route":
                      return RouteInfo("flask", _literal_methods_from_kwargs(dec) or ["GET"], _literal_str(dec.args[0]) if dec.args else None)
                  if attr=="command": return RouteInfo("typer","COMMAND",None)
              if isinstance(dec,ast.Attribute):
                  attr=dec.attr.lower()
                  if attr in {"get","post","put","delete","patch","options","head"}: return RouteInfo("fastapi", attr.upper(), None)
                  if attr=="route": return RouteInfo("flask", ["GET"], None)
                  if attr=="command": return RouteInfo("typer","COMMAND",None)
              return None

          class _DefCollector(ast.NodeVisitor):
              def __init__(self): self.stack=[]; self.defs=[]
              def visit_ClassDef(self,node): self.stack.append(node.name); self.generic_visit(node); self.stack.pop()
              def visit_FunctionDef(self,node): self._handle_def(node)
              def visit_AsyncFunctionDef(self,node): self._handle_def(node)
              def _handle_def(self,node):
                  qual=".".join(self.stack+[node.name]) if self.stack else node.name
                  params=[a.arg for a in list(node.args.posonlyargs)+list(node.args.args)]
                  if node.args.vararg: params.append("*"+node.args.vararg.arg)
                  if node.args.kwonlyargs: params += [ka.arg for ka in node.args.kwonlyargs]
                  if node.args.kwarg: params.append("**"+node.args.kwarg.arg)
                  decs=[_decorator_to_text(d) for d in node.decorator_list]
                  route=None
                  for d in node.decorator_list:
                      r=_detect_route(d)
                      if r: route=r; break
                  doc=ast.get_docstring(node)
                  self.defs.append(DefInfo(qual,node.name,getattr(node,"lineno",-1),params,decs,doc,route))

          def extract_python_file(py_path: Path) -> Dict[str,Any]:
              text = py_path.read_text(encoding="utf-8", errors="ignore")
              try: mod = ast.parse(text)
              except SyntaxError as e:
                  return {"path": str(py_path), "error": f"SyntaxError: {e}"}
              banner=_first_toplevel_string_after_imports(mod)
              module_doc=ast.get_docstring(mod)
              col=_DefCollector(); col.visit(mod)
              defs_out=[]
              for d in col.defs:
                  route_block=None
                  if d.route: route_block={"framework": d.route.framework, "method": d.route.method, "path": d.route.path}
                  defs_out.append({"qualname": d.qualname, "name": d.name, "lineno": d.lineno, "params": d.params, "decorators": d.decorators or [], "docstring": d.docstring or "", "route": route_block})
              return {"path": str(py_path), "banner": banner or "", "module_docstring": module_doc or "", "defs": defs_out}

          def main(argv: List[str]) -> int:
              root_arg=None; out_arg=None
              it=iter(argv)
              for a in it:
                  if a=="--root": root_arg=next(it,None)
                  elif a=="--out": out_arg=next(it,None)
              root=Path(root_arg) if root_arg else Path.cwd()
              if not root.exists():
                  print(f"[ERROR] Racine invalide: {root}", file=sys.stderr); return 2
              out_path=Path(out_arg) if out_arg else root / DEFAULT_OUT
              out_path.parent.mkdir(parents=True, exist_ok=True)
              all_files=iter_files(root)
              py_files=[p for p in all_files if p.suffix==".py"]
              project_name = root.name or ""
              if not project_name:
                  repo_env = os.environ.get("GITHUB_REPOSITORY")
                  if repo_env and "/" in repo_env:
                      project_name = repo_env.split("/", 1)[1]
                  else:
                      try:
                          project_name = os.path.basename(str(root.resolve()))
                      except Exception:
                          project_name = ""
              snapshot={
                  "snapshot": {
                      "project": project_name,
                      "root": str(root.resolve()),
                      "generated_at": datetime.utcnow().isoformat(timespec="seconds")+"Z",
                      "python": sys.version.split()[0],
                      "platform": platform.platform(),
                      "files_count": len(all_files),
                      "py_files_count": len(py_files),
                      "ignored_dirs": sorted(list(IGNORED_DIRS)),
                  },
                  "tree": ascii_tree(root),
                  "files": [],
              }
              for py in py_files:
                  item=extract_python_file(py)
                  try: item["relpath"]=str(py.relative_to(root)).replace(os.sep,"/")
                  except Exception: item["relpath"]=str(py)
                  snapshot["files"].append(item)
              with out_path.open("w", encoding="utf-8") as f:
                  yaml.dump(snapshot, f, Dumper=_LiteralDumper, sort_keys=False, allow_unicode=True, width=100)
              print(f"[OK] Contexte écrit → {out_path}")
              return 0

          if __name__ == "__main__":
              raise SystemExit(main(sys.argv[1:]))
          PY

          cat > scripts/generate_tiddler.py <<-'PY'
          #!/usr/bin/env python3
          from __future__ import annotations
          import sys, os, html, yaml
          from pathlib import Path
          from typing import Any, Dict

          def safe_read_yaml(p: Path) -> Dict[str,Any]:
              try:
                  return yaml.safe_load(p.read_text(encoding="utf-8")) or {}
              except Exception as e:
                  raise SystemExit(f"Cannot read YAML {p}: {e}")

          def render_html(snapshot: Dict[str,Any]) -> str:
              meta = snapshot.get("snapshot", {})
              tree = snapshot.get("tree","")
              files = snapshot.get("files",[])
              title = f"Context Snapshot — {html.escape(str(meta.get('project','')))}"
              css = """
              body{font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:18px}
              pre{background:#f6f8fa;padding:10px;border-radius:6px;overflow:auto}
              table{border-collapse:collapse;width:100%}
              th,td{border:1px solid #ddd;padding:6px;text-align:left;vertical-align:top}
              th{background:#efefef}
              .file{margin:14px 0;padding:8px;border-left:4px solid #2b6cb0;background:#fff}
              .banner{font-style:italic;color:#0b5;white-space:pre-wrap}
              .doc{color:#444}
              """
              parts = []
              parts.append(f"<html><head><meta charset='utf-8'><title>{title}</title><style>{css}</style></head><body>")
              parts.append(f"<h1>{title}</h1>")
              parts.append("<h2>Métadonnées</h2><table>")
              for k in ("project","root","generated_at","python","platform","files_count","py_files_count"):
                  parts.append(f"<tr><th>{html.escape(k)}</th><td>{html.escape(str(meta.get(k,'')))}</td></tr>")
              parts.append("</table>")
              parts.append("<h2>Arborescence</h2><pre>"+html.escape(tree)+"</pre>")
              parts.append(f"<h2>Fichiers ({len(files)})</h2>")
              for f in files:
                  parts.append("<div class='file'>")
                  parts.append(f"<h3>{html.escape(f.get('relpath', f.get('path','')))}</h3>")
                  banner = f.get("banner","") or ""
                  if banner:
                      parts.append("<div class='banner'><pre>"+html.escape(banner)+"</pre></div>")
                  module_doc = f.get("module_docstring","") or ""
                  if module_doc:
                      parts.append("<div class='doc'><strong>Module doc:</strong><pre>"+html.escape(module_doc)+"</pre></div>")
                  defs = f.get("defs",[])
                  if defs:
                      parts.append("<table><thead><tr><th>qualname</th><th>lineno</th><th>params</th><th>decorators</th><th>route</th><th>docstring</th></tr></thead><tbody>")
                      for d in defs:
                          route = d.get("route") or {}
                          route_txt = ""
                          if route:
                              route_txt = html.escape(str(route))
                          parts.append("<tr>")
                          parts.append(f"<td>{html.escape(d.get('qualname',''))}</td>")
                          parts.append(f"<td>{html.escape(str(d.get('lineno','')))}</td>")
                          parts.append(f"<td>{html.escape(', '.join(d.get('params') or []))}</td>")
                          parts.append(f"<td>{html.escape(', '.join(d.get('decorators') or []))}</td>")
                          parts.append(f"<td>{route_txt}</td>")
                          parts.append(f"<td><pre>{html.escape(d.get('docstring') or '')}</pre></td>")
                          parts.append("</tr>")
                      parts.append("</tbody></table>")
                  parts.append("</div>")
              parts.append("</body></html>")
              return "\n".join(parts)

          def main(argv):
              in_path = Path(".archcode/context_snapshot.yaml")
              out_path = Path(".archcode/context_snapshot_tiddler.html")
              if len(argv) >= 2:
                  in_path = Path(argv[0])
                  out_path = Path(argv[1])
              if not in_path.exists():
                  print(f"[ERROR] input not found: {in_path}", file=sys.stderr); return 2
              snapshot = safe_read_yaml(in_path)
              html_txt = render_html(snapshot)
              out_path.parent.mkdir(parents=True, exist_ok=True)
              out_path.write_text(html_txt, encoding="utf-8")
              print(f"[OK] wrote tiddler -> {out_path}")
              return 0

          if __name__ == "__main__":
              raise SystemExit(main(sys.argv[1:] or []))
          PY

      - name: Run snapshot
        run: |
          python scripts/context_snapshot.py --root . --out .archcode/context_snapshot.yaml
          test -f .archcode/context_snapshot.yaml || (echo "Fichier non généré !" && exit 1)

      - name: Generate tiddler
        run: |
          python scripts/generate_tiddler.py .archcode/context_snapshot.yaml .archcode/context_snapshot_tiddler.html
          test -f .archcode/context_snapshot_tiddler.html || (echo "Tiddler non généré !" && exit 1)

      - name: Debug output
        run: |
          echo "=== Listing .archcode directory ==="
          ls -la .archcode || echo ".archcode does not exist"
          echo "=== Full tree ==="
          find . -type f | sort

      - name: Upload context as artifact
        uses: actions/upload-artifact@v4
        with:
          name: context_snapshot
          path: |
            .archcode/context_snapshot.yaml
            .archcode/context_snapshot_tiddler.html
          if-no-files-found: error

      - name: Commit snapshot to main
        run: |
          set -e
          git config user.name "archcode-bot"
          git config user.email "archcode-bot@users.noreply.github.com"
          git checkout main
          git pull --rebase origin main || true
          git add -f .archcode/context_snapshot.yaml scripts/context_snapshot.py scripts/generate_tiddler.py
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore(context): refresh context_snapshot.yaml + tiddler"
            git push origin main || echo "::warning::Push vers main refusé (branche protégée). Le fichier reste disponible en Artifacts."
          fi
