name: Context Snapshot (mARCHCode)

on:
  workflow_dispatch:  # lancement manuel
  # push:            # facultatif : réactive si tu veux snapshots automatiques
  #   paths:
  #     - "**/*.py"
  #     - ".github/workflows/context-snapshot.yml"

permissions:
  contents: write

jobs:
  snapshot:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install pyyaml

      - name: Create scripts dir
        run: mkdir -p scripts .archcode

      - name: Add snapshot script
        shell: bash
        run: |
          cat > scripts/context_snapshot.py <<'PY'
          #!/usr/bin/env python3
          from __future__ import annotations

          import ast
          import sys
          import os
          import platform
          import yaml
          from dataclasses import dataclass
          from pathlib import Path
          from typing import Any, Dict, List, Optional, Union
          from datetime import datetime

          IGNORED_DIRS = {
              ".git",
              "__pycache__",
              ".venv",
              "venv",
              ".env",
              ".mypy_cache",
              ".pytest_cache",
              "node_modules",
              ".idea",
              ".vscode",
          }
          DEFAULT_OUT = ".archcode/context_snapshot.yaml"

          # Dumper that uses block style for multiline strings
          class _LiteralDumper(yaml.SafeDumper):
              pass

          def _repr_str(dumper: yaml.Dumper, data: str):
              style = "|" if ("\n" in data) else None
              return dumper.represent_scalar("tag:yaml.org,2002:str", data, style=style)

          _LiteralDumper.add_representer(str, _repr_str)

          def iter_files(root: Path) -> List[Path]:
              files: List[Path] = []
              for p in sorted(root.rglob("*")):
                  try:
                      rel = p.relative_to(root)
                  except Exception:
                      # ignore paths we cannot relativize
                      continue
                  if any(seg in IGNORED_DIRS for seg in rel.parts):
                      continue
                  if p.is_file():
                      files.append(p)
              return files

          def ascii_tree(root: Path) -> str:
              lines: List[str] = [str(root.resolve())]

              def children(d: Path) -> List[Path]:
                  ch: List[Path] = []
                  try:
                      it = sorted(d.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower()))
                  except Exception:
                      return ch
                  for p in it:
                      try:
                          rel = p.relative_to(root)
                      except Exception:
                          continue
                      if any(seg in IGNORED_DIRS for seg in rel.parts):
                          continue
                      ch.append(p)
                  return ch

              def walk(d: Path, prefix: str = "") -> None:
                  kids = children(d)
                  for i, k in enumerate(kids):
                      joint = "└── " if i == len(kids) - 1 else "├── "
                      lines.append(f"{prefix}{joint}{k.name}")
                      if k.is_dir():
                          ext = "    " if i == len(kids) - 1 else "│   "
                          walk(k, prefix + ext)

              walk(root)
              return "\n".join(lines)

          @dataclass
          class RouteInfo:
              framework: str
              method: Optional[Union[str, List[str]]] = None
              path: Optional[str] = None

          @dataclass
          class DefInfo:
              qualname: str
              name: str
              lineno: int
              params: List[str]
              decorators: List[str]
              docstring: Optional[str]
              route: Optional[RouteInfo]

          def _first_toplevel_string_after_imports(module: ast.Module) -> Optional[str]:
              for node in module.body:
                  if isinstance(node, ast.Expr) and isinstance(getattr(node, "value", None), ast.Constant):
                      if isinstance(node.value.value, str):
                          return node.value.value
              return None

          def _decorator_to_text(dec: ast.AST) -> str:
              def name_of(n: ast.AST) -> str:
                  if isinstance(n, ast.Name):
                      return n.id
                  if isinstance(n, ast.Attribute):
                      return f"{name_of(n.value)}.{n.attr}"
                  if isinstance(n, ast.Call):
                      return name_of(n.func)
                  return n.__class__.__name__
              return name_of(dec)

          def _literal_str(node: ast.AST) -> Optional[str]:
              if isinstance(node, ast.Constant) and isinstance(node.value, str):
                  return node.value
              return None

          def _literal_methods_from_kwargs(call: ast.Call) -> Optional[List[str]]:
              for kw in call.keywords:
                  if kw.arg in {"methods", "method"}:
                      val = kw.value
                      if isinstance(val, ast.List):
                          out: List[str] = []
                          for elt in val.elts:
                              if isinstance(elt, ast.Constant) and isinstance(elt.value, str):
                                  out.append(elt.value.upper())
                          return out or None
                      if isinstance(val, ast.Constant) and isinstance(val.value, str):
                          return [val.value.upper()]
              return None

          def _detect_route(dec: ast.AST) -> Optional[RouteInfo]:
              if isinstance(dec, ast.Call):
                  func = dec.func
                  if isinstance(func, ast.Attribute):
                      attr = func.attr.lower()
                      if attr in {"get", "post", "put", "delete", "patch", "options", "head"}:
                          route_path = _literal_str(dec.args[0]) if dec.args else None
                          return RouteInfo(framework="fastapi", method=attr.upper(), path=route_path)
                      if attr == "route":
                          route_path = _literal_str(dec.args[0]) if dec.args else None
                          methods = _literal_methods_from_kwargs(dec) or ["GET"]
                          return RouteInfo(framework="flask", method=methods, path=route_path)
                      if attr == "command":
                          return RouteInfo(framework="typer", method="COMMAND", path=None)
              if isinstance(dec, ast.Attribute):
                  attr = dec.attr.lower()
                  if attr in {"get", "post", "put", "delete", "patch", "options", "head"}:
                      return RouteInfo(framework="fastapi", method=attr.upper(), path=None)
                  if attr == "route":
                      return RouteInfo(framework="flask", method=["GET"], path=None)
                  if attr == "command":
                      return RouteInfo(framework="typer", method="COMMAND", path=None)
              return None

          class _DefCollector(ast.NodeVisitor):
              def __init__(self) -> None:
                  self.stack: List[str] = []
                  self.defs: List[DefInfo] = []

              def visit_ClassDef(self, node: ast.ClassDef) -> Any:
                  self.stack.append(node.name)
                  self.generic_visit(node)
                  self.stack.pop()

              def visit_FunctionDef(self, node: ast.FunctionDef) -> Any:
                  self._handle_def(node)

              def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Any:
                  self._handle_def(node)

              def _handle_def(self, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]) -> None:
                  qual = ".".join(self.stack + [node.name]) if self.stack else node.name
                  params = [a.arg for a in list(node.args.posonlyargs) + list(node.args.args)]
                  if node.args.vararg:
                      params.append("*" + node.args.vararg.arg)
                  if node.args.kwonlyargs:
                      params += [ka.arg for ka in node.args.kwonlyargs]
                  if node.args.kwarg:
                      params.append("**" + node.args.kwarg.arg)

                  decorators_text = [_decorator_to_text(d) for d in node.decorator_list]
                  route_info: Optional[RouteInfo] = None
                  for d in node.decorator_list:
                      r = _detect_route(d)
                      if r:
                          route_info = r
                          break

                  doc = ast.get_docstring(node)

                  self.defs.append(
                      DefInfo(
                          qualname=qual,
                          name=node.name,
                          lineno=getattr(node, "lineno", -1),
                          params=params,
                          decorators=decorators_text,
                          docstring=doc,
                          route=route_info,
                      )
                  )

          def extract_python_file(py_path: Path) -> Dict[str, Any]:
              text = py_path.read_text(encoding="utf-8", errors="ignore")
              try:
                  mod = ast.parse(text)
              except SyntaxError as e:
                  return {"path": str(py_path), "error": f"SyntaxError: {e}"}

              banner = _first_toplevel_string_after_imports(mod)
              module_doc = ast.get_docstring(mod)

              collector = _DefCollector()
              collector.visit(mod)

              defs_out: List[Dict[str, Any]] = []
              for d in collector.defs:
                  route_block: Optional[Dict[str, Any]] = None
                  if d.route:
                      route_block = {"framework": d.route.framework, "method": d.route.method, "path": d.route.path}
                  defs_out.append(
                      {
                          "qualname": d.qualname,
                          "name": d.name,
                          "lineno": d.lineno,
                          "params": d.params,
                          "decorators": d.decorators or [],
                          "docstring": d.docstring or "",
                          "route": route_block,
                      }
                  )

              return {"path": str(py_path), "banner": banner or "", "module_docstring": module_doc or "", "defs": defs_out}

          def main(argv: List[str]) -> int:
              root_arg: Optional[str] = None
              out_arg: Optional[str] = None
              it = iter(argv)
              for a in it:
                  if a == "--root":
                      root_arg = next(it, None)
                  elif a == "--out":
                      out_arg = next(it, None)

              root = Path(root_arg) if root_arg else Path.cwd()
              if not root.exists():
                  print(f"[ERROR] Racine invalide: {root}", file=sys.stderr)
                  return 2

              out_path = Path(out_arg) if out_arg else root / DEFAULT_OUT
              out_path.parent.mkdir(parents=True, exist_ok=True)

              all_files = iter_files(root)
              py_files = [p for p in all_files if p.suffix == ".py"]

              # robust project name fallback
              project_name = root.name or ""
              if not project_name:
                  repo_env = os.environ.get("GITHUB_REPOSITORY")
                  if repo_env and "/" in repo_env:
                      project_name = repo_env.split("/", 1)[1]
                  else:
                      try:
                          project_name = os.path.basename(str(root.resolve()))
                      except Exception:
                          project_name = ""

              snapshot: Dict[str, Any] = {
                  "snapshot": {
                      "project": project_name,
                      "root": str(root.resolve()),
                      "generated_at": datetime.utcnow().isoformat(timespec="seconds") + "Z",
                      "python": sys.version.split()[0],
                      "platform": platform.platform(),
                      "files_count": len(all_files),
                      "py_files_count": len(py_files),
                      "ignored_dirs": sorted(list(IGNORED_DIRS)),
                  },
                  "tree": ascii_tree(root),
                  "files": [],
              }

              for py in py_files:
                  item = extract_python_file(py)
                  try:
                      item["relpath"] = str(py.relative_to(root)).replace(os.sep, "/")
                  except Exception:
                      item["relpath"] = str(py)
                  snapshot["files"].append(item)

              with out_path.open("w", encoding="utf-8") as f:
                  yaml.dump(snapshot, f, Dumper=_LiteralDumper, sort_keys=False, allow_unicode=True, width=100)

              print(f"[OK] Contexte écrit → {out_path}")
              return 0

          if __name__ == "__main__":
              raise SystemExit(main(sys.argv[1:]))
          PY

      - name: Run snapshot
        run: |
          python scripts/context_snapshot.py --root . --out .archcode/context_snapshot.yaml
          test -f .archcode/context_snapshot.yaml || (echo "Fichier non généré !" && exit 1)

      - name: Generate tiddler HTML from YAML
        shell: bash
        run: |
          python - <<'PY'
          import yaml, html, sys
          from pathlib import Path
          p = Path(".archcode/context_snapshot.yaml")
          out = Path(".archcode/context_snapshot_tiddler.html")
          if not p.exists():
              print("No snapshot YAML found", file=sys.stderr); raise SystemExit(2)
          s = yaml.safe_load(p.read_text(encoding="utf-8"))
          parts = []
          meta = s.get("snapshot", {})
          proj = html.escape(meta.get("project",""))
          parts.append(f"<html><head><meta charset='utf-8'><title>Context Snapshot — {proj}</title></head><body>")
          parts.append(f"<h1>Context Snapshot — {proj}</h1>")
          parts.append("<h2>Metadata</h2><ul>")
          for k in ("root","generated_at","python","platform","files_count","py_files_count"):
              parts.append(f"<li><strong>{html.escape(str(k))}</strong>: {html.escape(str(meta.get(k,'')))}</li>")
          parts.append("</ul>")
          parts.append("<h2>Project tree</h2><pre style='background:#f7f7f7;padding:8px;border:1px solid #ddd;'>")
          parts.append(html.escape(s.get("tree","")))
          parts.append("</pre>")
          parts.append("<h2>Files (summary)</h2>")
          for f in s.get("files", []):
              rel = html.escape(f.get("relpath", f.get("path","")))
              parts.append(f"<h3>{rel}</h3>")
              if f.get("banner"):
                  parts.append("<pre style='background:#fff8e1;padding:6px;border:1px solid #eee;'>"+html.escape(f.get("banner"))+"</pre>")
              if f.get("module_docstring"):
                  parts.append("<p><em>"+html.escape(f.get("module_docstring"))+"</em></p>")
              if f.get("defs"):
                  parts.append("<ul>")
                  for d in f["defs"][:20]:
                      q = html.escape(d.get("qualname",""))
                      ln = d.get("lineno","")
                      ds = html.escape((d.get("docstring") or "").strip().splitlines()[0] if d.get("docstring") else "")
                      parts.append(f"<li><strong>{q}</strong> (line {ln}) — {ds}</li>")
                  parts.append("</ul>")
          parts.append("</body></html>")
          out.write_text("\n".join(parts), encoding="utf-8")
          print("Wrote tiddler to", out)
          PY
          test -f .archcode/context_snapshot_tiddler.html || (echo "Tiddler not generated!" && exit 1)

      - name: Upload context as artifact
        uses: actions/upload-artifact@v4
        with:
          name: context_snapshot
          path: |
            .archcode/context_snapshot.yaml
            .archcode/context_snapshot_tiddler.html
          if-no-files-found: error

      - name: Debug output
        run: |
          echo "=== Listing .archcode directory ==="
          ls -la .archcode || echo ".archcode does not exist"
          echo "=== Full tree ==="
          find . -type f | sort

      # optional: try to commit to main, but fail gracefully if protected
      - name: Commit snapshot to main (best-effort)
        run: |
          set -e
          git config user.name "archcode-bot"
          git config user.email "archcode-bot@users.noreply.github.com"
          git checkout main || git checkout -b main
          git pull --rebase origin main || true
          git add -f .archcode/context_snapshot.yaml scripts/context_snapshot.py
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore(context): refresh context_snapshot.yaml"
            git push origin main || echo "::warning::Push vers main refusé (branche protégée). Le fichier reste disponible en Artifacts."
          fi
