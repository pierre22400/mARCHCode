name: Context Snapshot (mARCHCode)

on:
  workflow_dispatch:  # lancement manuel

permissions:
  contents: write

jobs:
  snapshot:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install pyyaml

      - name: Create scripts dir
        run: mkdir -p scripts .archcode

      - name: Add snapshot script
        run: |
          cat > scripts/context_snapshot.py << 'PY'
          # ICI → mettre le script complet que je t’ai donné
          PY

      - name: Run snapshot
        run: |
          mkdir -p .archcode
          python scripts/context_snapshot.py --root . --out .archcode/context_snapshot.yaml
          test -f .archcode/context_snapshot.yaml || (echo "Fichier non généré !" && exit 1)
      - name: Debug output
        run: |
          echo "=== Listing .archcode directory ==="
          ls -la .archcode || echo ".archcode does not exist"
          echo "=== Full tree ==="
          find . -type f | sort

      - name: Commit snapshot (force add)
        run: |
          git config user.name "archcode-bot"
          git config user.email "archcode-bot@users.noreply.github.com"
          git add -f .archcode/context_snapshot.yaml scripts/context_snapshot.py
          git commit -m "update context snapshot [force]" || echo "No changes to commit"
          git pull --rebase origin main
          git push origin main

          # scripts/context_snapshot.py
          from __future__ import annotations

          import ast
          import sys
          import os
          from dataclasses import dataclass
          from pathlib import Path
          from typing import Any, Dict, List, Optional, Tuple, Union
          from datetime import datetime
          import platform

          import yaml  # PyYAML


          """
          # ============================================================
          # Context Snapshot — Mémoire de session pour mARCHCode (v0.2)
          # ============================================================
          # Rôle du script
          #   Donner au LLM un "contexte court" et fiable à chaque session :
          #     1) Extraire l’ARBORESCENCE complète du projet (hors dossiers ignorés)
          #     2) Capturer la bannière docstring pédagogique de chaque fichier .py
          #        (y compris si elle est placée APRES les imports — cas mARCHCode)
          #     3) Lister toutes les définitions de fonctions (et méthodes) avec :
          #        - qualname, ligne, paramètres, docstring
          #        - détection best-effort des ROUTES (FastAPI/Flask/Typer)
          #     4) Écrire le tout au format YAML très simple :
          #        `.archcode/context_snapshot.yaml`
          #
          # Pourquoi ?
          #   → Réduire les dérives sémantiques et les confusions sur les noms.
          #   → Permettre à Pierre de "rebouster" le contexte en début de session.
          #
          # Usage minimal
          #   $ python scripts/context_snapshot.py
          #   - Racine projet = dossier courant (ou auto-détectée)
          #   - Sortie = .archcode/context_snapshot.yaml
          #
          # Options (facultatives)
          #   $ python scripts/context_snapshot.py --root <chemin> --out <fichier.yaml>
          #
          # Notes d’implémentation
          #   - On ignore .git, __pycache__, venv, caches, etc.
          #   - La "bannière" est le 1er string toplevel (Expr str) même après imports.
          #     Si absente, on essaie la docstring de module via ast.get_docstring().
          #   - Signatures : on liste les paramètres (noms) pour rester robuste.
          #   - Routes : heuristique sur décorateurs (@router.get, @app.route, @app.command)
          #     → on extrait method/path quand c’est un littéral simple.
          #
          # Changements v0.2 — 2025-08-13
          #   - Ajout ascii tree dans `tree` (bloc texte).
          #   - Détection élargie des routes (FastAPI/Flask/Typer).
          #   - YAML compact mais lisible, unicode, stable.
          # ============================================================
          """


          IGNORED_DIRS = {
              ".git",
              "__pycache__",
              ".venv",
              "venv",
              ".env",
              ".mypy_cache",
              ".pytest_cache",
              "node_modules",
              ".idea",
              ".vscode",
          }

          DEFAULT_OUT = ".archcode/context_snapshot.yaml"


          class _LiteralDumper(yaml.SafeDumper):
              """Dumper: chaînes multi-lignes en bloc `|` quand pertinent."""


          def _repr_str(dumper: yaml.Dumper, data: str):  # type: ignore[name-defined]
              style = "|" if ("\n" in data) else None
              return dumper.represent_scalar("tag:yaml.org,2002:str", data, style=style)


          _LiteralDumper.add_representer(str, _repr_str)


          def iter_files(root: Path) -> List[Path]:
              files: List[Path] = []
              for p in sorted(root.rglob("*")):
                  if p.is_dir():
                      parts = set(p.parts)
                      if parts & IGNORED_DIRS:
                          continue
                      continue
                  if any(seg in IGNORED_DIRS for seg in p.parts):
                      continue
                  files.append(p)
              return files


          def ascii_tree(root: Path) -> str:
              lines: List[str] = [str(root.resolve())]
              def children(d: Path) -> List[Path]:
                  ch = []
                  for p in sorted(d.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower())):
                      if any(seg in IGNORED_DIRS for seg in p.relative_to(root).parts):
                          continue
                      ch.append(p)
                  return ch

              def walk(d: Path, prefix: str = "") -> None:
                  kids = children(d)
                  for i, k in enumerate(kids):
                      joint = "└── " if i == len(kids) - 1 else "├── "
                      lines.append(f"{prefix}{joint}{k.name}")
                      if k.is_dir():
                          ext = "    " if i == len(kids) - 1 else "│   "
                          walk(k, prefix + ext)

              walk(root)
              return "\n".join(lines)


          @dataclass
          class RouteInfo:
              framework: str
              method: Optional[Union[str, List[str]]] = None
              path: Optional[str] = None


          @dataclass
          class DefInfo:
              qualname: str
              name: str
              lineno: int
              params: List[str]
              decorators: List[str]
              docstring: Optional[str]
              route: Optional[RouteInfo]


          def _first_toplevel_string_after_imports(module: ast.Module) -> Optional[str]:
              for node in module.body:
                  if isinstance(node, ast.Expr) and isinstance(getattr(node, "value", None), ast.Constant):
                      if isinstance(node.value.value, str):
                          return node.value.value
              return None


          def _decorator_to_text(dec: ast.AST) -> str:
              def name_of(n: ast.AST) -> str:
                  if isinstance(n, ast.Name):
                      return n.id
                  if isinstance(n, ast.Attribute):
                      return f"{name_of(n.value)}.{n.attr}"
                  if isinstance(n, ast.Call):
                      return name_of(n.func)
                  return n.__class__.__name__
              return name_of(dec)


          def _literal_str(node: ast.AST) -> Optional[str]:
              if isinstance(node, ast.Constant) and isinstance(node.value, str):
                  return node.value
              return None


          def _literal_methods_from_kwargs(call: ast.Call) -> Optional[List[str]]:
              for kw in call.keywords:
                  if kw.arg in {"methods", "method"}:
                      val = kw.value
                      if isinstance(val, ast.List):
                          out: List[str] = []
                          for elt in val.elts:
                              if isinstance(elt, ast.Constant) and isinstance(elt.value, str):
                                  out.append(elt.value.upper())
                          return out or None
                      if isinstance(val, ast.Constant) and isinstance(val.value, str):
                          return [val.value.upper()]
              return None


          def _detect_route(dec: ast.AST) -> Optional[RouteInfo]:
              if isinstance(dec, ast.Call):
                  func = dec.func
                  if isinstance(func, ast.Attribute):
                      attr = func.attr.lower()
                      base = _decorator_to_text(func.value)
                      if attr in {"get", "post", "put", "delete", "patch", "options", "head"}:
                          route_path = _literal_str(dec.args[0]) if dec.args else None
                          return RouteInfo(framework="fastapi", method=attr.upper(), path=route_path)
                      if attr == "route":
                          route_path = _literal_str(dec.args[0]) if dec.args else None
                          methods = _literal_methods_from_kwargs(dec) or ["GET"]
                          return RouteInfo(framework="flask", method=methods, path=route_path)
                      if attr == "command":
                          return RouteInfo(framework="typer", method="COMMAND", path=None)
              if isinstance(dec, ast.Attribute):
                  attr = dec.attr.lower()
                  if attr in {"get", "post", "put", "delete", "patch", "options", "head"}:
                      return RouteInfo(framework="fastapi", method=attr.upper(), path=None)
                  if attr == "route":
                      return RouteInfo(framework="flask", method=["GET"], path=None)
                  if attr == "command":
                      return RouteInfo(framework="typer", method="COMMAND", path=None)
              return None


          class _DefCollector(ast.NodeVisitor):
              def __init__(self) -> None:
                  self.stack: List[str] = []
                  self.defs: List[DefInfo] = []

              def visit_ClassDef(self, node: ast.ClassDef) -> Any:
                  self.stack.append(node.name)
                  self.generic_visit(node)
                  self.stack.pop()

              def visit_FunctionDef(self, node: ast.FunctionDef) -> Any:
                  self._handle_def(node)

              def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Any:
                  self._handle_def(node)

              def _handle_def(self, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]) -> None:
                  qual = ".".join(self.stack + [node.name]) if self.stack else node.name
                  params = [a.arg for a in list(node.args.posonlyargs) + list(node.args.args)]
                  if node.args.vararg:
                      params.append("*" + node.args.vararg.arg)
                  if node.args.kwonlyargs:
                      params += [ka.arg for ka in node.args.kwonlyargs]
                  if node.args.kwarg:
                      params.append("**" + node.args.kwarg.arg)

                  decorators_text = [_decorator_to_text(d) for d in node.decorator_list]
                  route_info: Optional[RouteInfo] = None
                  for d in node.decorator_list:
                      r = _detect_route(d)
                      if r:
                          route_info = r
                          break

                  doc = ast.get_docstring(node)

                  self.defs.append(
                      DefInfo(
                          qualname=qual,
                          name=node.name,
                          lineno=getattr(node, "lineno", -1),
                          params=params,
                          decorators=decorators_text,
                          docstring=doc,
                          route=route_info,
                      )
                  )


          def extract_python_file(py_path: Path) -> Dict[str, Any]:
              text = py_path.read_text(encoding="utf-8", errors="ignore")
              try:
                  mod = ast.parse(text)
              except SyntaxError as e:
                  return {
                      "path": str(py_path),
                      "error": f"SyntaxError: {e}",
                  }

              banner = _first_toplevel_string_after_imports(mod)
              module_doc = ast.get_docstring(mod)

              collector = _DefCollector()
              collector.visit(mod)

              defs_out: List[Dict[str, Any]] = []
              for d in collector.defs:
                  route_block: Optional[Dict[str, Any]] = None
                  if d.route:
                      route_block = {
                          "framework": d.route.framework,
                          "method": d.route.method,
                          "path": d.route.path,
                      }

                  defs_out.append(
                      {
                          "qualname": d.qualname,
                          "name": d.name,
                          "lineno": d.lineno,
                          "params": d.params,
                          "decorators": d.decorators or [],
                          "docstring": d.docstring or "",
                          "route": route_block,
                      }
                  )

              return {
                  "path": str(py_path),
                  "banner": banner or "",
                  "module_docstring": module_doc or "",
                  "defs": defs_out,
              }


          def iter_files(root: Path) -> List[Path]:
              files: List[Path] = []
              for p in sorted(root.rglob("*")):
                  if p.is_dir():
                      parts = set(p.parts)
                      if parts & IGNORED_DIRS:
                          continue
                      continue
                  if any(seg in IGNORED_DIRS for seg in p.parts):
                      continue
                  files.append(p)
              return files


          def main(argv: List[str]) -> int:
              root_arg: Optional[str] = None
              out_arg: Optional[str] = None
              it = iter(argv)
              for a in it:
                  if a == "--root":
                      root_arg = next(it, None)
                  elif a == "--out":
                      out_arg = next(it, None)

              root = Path(root_arg) if root_arg else Path.cwd()
              if not root.exists():
                  print(f"[ERROR] Racine invalide: {root}", file=sys.stderr)
                  return 2

              out_path = Path(out_arg) if out_arg else root_
