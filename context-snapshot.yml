name: Context Snapshot (mARCHCode)

on:
  workflow_dispatch:  # lancement manuel

permissions:
  contents: write

jobs:
  snapshot:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install pyyaml

      - name: Create scripts dir
        run: mkdir -p scripts .archcode

      - name: Add snapshot script
        shell: bash
        run: |
          cat > scripts/context_snapshot.py <<-'PY'
          from __future__ import annotations

          """
          ============================================================
          Context Snapshot — Mémoire de session pour mARCHCode (v0.2)
          ============================================================
          Rôle:
            - Extraire l'arborescence du projet (exclut IGNORED_DIRS)
            - Capturer la bannière docstring pédagogique de chaque .py
            - Lister defs/méthodes (qualname, lineno, params, docstring)
            - Détecter routes (FastAPI/Flask/Typer) heuristiquement
            - Ecrire un YAML lisible → .archcode/context_snapshot.yaml

          Usage:
            python scripts/context_snapshot.py --root <racine> --out <fichier.yaml>
            (par défaut: root = cwd, out = .archcode/context_snapshot.yaml)
          ============================================================
          """

          import ast
          import sys
          import os
          from dataclasses import dataclass
          from pathlib import Path
          from typing import Any, Dict, List, Optional, Union
          from datetime import datetime
          import platform
          import yaml  # PyYAML

          IGNORED_DIRS = {
              ".git",
              "__pycache__",
              ".venv",
              "venv",
              ".env",
              ".mypy_cache",
              ".pytest_cache",
              "node_modules",
              ".idea",
              ".vscode",
          }

          DEFAULT_OUT = ".archcode/context_snapshot.yaml"

          class _LiteralDumper(yaml.SafeDumper):
              """Dumper : force les chaînes multi-lignes en bloc '|' quand pertinent."""
              pass

          def _repr_str(dumper: yaml.Dumper, data: str):
              style = "|" if ("\n" in data) else None
              return dumper.represent_scalar("tag:yaml.org,2002:str", data, style=style)

          _LiteralDumper.add_representer(str, _repr_str)

          def iter_files(root: Path) -> List[Path]:
              files: List[Path] = []
              for p in sorted(root.rglob("*")):
                  try:
                      rel = p.relative_to(root)
                  except Exception:
                      continue
                  # skip ignored dirs anywhere in path
                  if any(seg in IGNORED_DIRS for seg in rel.parts):
                      continue
                  if p.is_file():
                      files.append(p)
              return files

          def ascii_tree(root: Path) -> str:
              lines: List[str] = [str(root.resolve())]

              def kids(d: Path) -> List[Path]:
                  out: List[Path] = []
                  try:
                      it = sorted(d.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower()))
                  except Exception:
                      return out
                  for p in it:
                      try:
                          rel = p.relative_to(root)
                      except Exception:
                          continue
                      if any(seg in IGNORED_DIRS for seg in rel.parts):
                          continue
                      out.append(p)
                  return out

              def walk(d: Path, prefix: str = "") -> None:
                  ch = kids(d)
                  for i, k in enumerate(ch):
                      joint = "└── " if i == len(ch) - 1 else "├── "
                      lines.append(f"{prefix}{joint}{k.name}")
                      if k.is_dir():
                          ext = "    " if i == len(ch) - 1 else "│   "
                          walk(k, prefix + ext)

              walk(root)
              return "\n".join(lines)

          @dataclass
          class RouteInfo:
              framework: str
              method: Optional[Union[str, List[str]]] = None
              path: Optional[str] = None

          @dataclass
          class DefInfo:
              qualname: str
              name: str
              lineno: int
              params: List[str]
              decorators: List[str]
              docstring: Optional[str]
              route: Optional[RouteInfo]

          def _first_toplevel_string_after_imports(module: ast.Module) -> Optional[str]:
              for node in module.body:
                  # Expr(Constant(str)) is a module-level string literal
                  if isinstance(node, ast.Expr) and isinstance(getattr(node, "value", None), ast.Constant):
                      if isinstance(node.value.value, str):
                          return node.value.value
              return None

          def _decorator_to_text(dec: ast.AST) -> str:
              def name_of(n: ast.AST) -> str:
                  if isinstance(n, ast.Name):
                      return n.id
                  if isinstance(n, ast.Attribute):
                      return f"{name_of(n.value)}.{n.attr}"
                  if isinstance(n, ast.Call):
                      return name_of(n.func)
                  return n.__class__.__name__
              return name_of(dec)

          def _literal_str(node: ast.AST) -> Optional[str]:
              if isinstance(node, ast.Constant) and isinstance(node.value, str):
                  return node.value
              return None

          def _literal_methods_from_kwargs(call: ast.Call) -> Optional[List[str]]:
              for kw in call.keywords:
                  if kw.arg in {"methods", "method"}:
                      val = kw.value
                      if isinstance(val, ast.List):
                          out: List[str] = []
                          for elt in val.elts:
                              if isinstance(elt, ast.Constant) and isinstance(elt.value, str):
                                  out.append(elt.value.upper())
                          return out or None
                      if isinstance(val, ast.Constant) and isinstance(val.value, str):
                          return [val.value.upper()]
              return None

          def _detect_route(dec: ast.AST) -> Optional[RouteInfo]:
              # heuristique : @router.get("/x") or @app.route("/x", methods=["POST"])
              if isinstance(dec, ast.Call) and isinstance(dec.func, ast.Attribute):
                  attr = dec.func.attr.lower()
                  if attr in {"get", "post", "put", "delete", "patch", "options", "head"}:
                      route_path = _literal_str(dec.args[0]) if dec.args else None
                      return RouteInfo(framework="fastapi", method=attr.upper(), path=route_path)
                  if attr == "route":
                      route_path = _literal_str(dec.args[0]) if dec.args else None
                      methods = _literal_methods_from_kwargs(dec) or ["GET"]
                      return RouteInfo(framework="flask", method=methods, path=route_path)
                  if attr == "command":
                      return RouteInfo(framework="typer", method="COMMAND", path=None)
              if isinstance(dec, ast.Attribute):
                  attr = dec.attr.lower()
                  if attr in {"get", "post", "put", "delete", "patch", "options", "head"}:
                      return RouteInfo(framework="fastapi", method=attr.upper(), path=None)
                  if attr == "route":
                      return RouteInfo(framework="flask", method=["GET"], path=None)
                  if attr == "command":
                      return RouteInfo(framework="typer", method="COMMAND", path=None)
              return None

          class _DefCollector(ast.NodeVisitor):
              def __init__(self) -> None:
                  self.stack: List[str] = []
                  self.defs: List[DefInfo] = []

              def visit_ClassDef(self, node: ast.ClassDef) -> Any:
                  self.stack.append(node.name)
                  self.generic_visit(node)
                  self.stack.pop()

              def visit_FunctionDef(self, node: ast.FunctionDef) -> Any:
                  self._handle_def(node)

              def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Any:
                  self._handle_def(node)

              def _handle_def(self, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]) -> None:
                  qual = ".".join(self.stack + [node.name]) if self.stack else node.name
                  params = [a.arg for a in list(node.args.posonlyargs) + list(node.args.args)]
                  if node.args.vararg:
                      params.append("*" + node.args.vararg.arg)
                  if node.args.kwonlyargs:
                      params += [ka.arg for ka in node.args.kwonlyargs]
                  if node.args.kwarg:
                      params.append("**" + node.args.kwarg.arg)

                  decorators_text = [_decorator_to_text(d) for d in node.decorator_list]
                  route_info: Optional[RouteInfo] = None
                  for d in node.decorator_list:
                      r = _detect_route(d)
                      if r:
                          route_info = r
                          break

                  doc = ast.get_docstring(node)

                  self.defs.append(
                      DefInfo(
                          qualname=qual,
                          name=node.name,
                          lineno=getattr(node, "lineno", -1),
                          params=params,
                          decorators=decorators_text,
                          docstring=doc,
                          route=route_info,
                      )
                  )

          def extract_python_file(py_path: Path) -> Dict[str, Any]:
              text = py_path.read_text(encoding="utf-8", errors="ignore")
              try:
                  mod = ast.parse(text)
              except SyntaxError as e:
                  return {
                      "path": str(py_path),
                      "error": f"SyntaxError: {e}",
                  }

              banner = _first_toplevel_string_after_imports(mod)
              module_doc = ast.get_docstring(mod)

              collector = _DefCollector()
              collector.visit(mod)

              defs_out: List[Dict[str, Any]] = []
              for d in collector.defs:
                  route_block: Optional[Dict[str, Any]] = None
                  if d.route:
                      route_block = {
                          "framework": d.route.framework,
                          "method": d.route.method,
                          "path": d.route.path,
                      }

                  defs_out.append(
                      {
                          "qualname": d.qualname,
                          "name": d.name,
                          "lineno": d.lineno,
                          "params": d.params,
                          "decorators": d.decorators or [],
                          "docstring": d.docstring or "",
                          "route": route_block,
                      }
                  )

              return {
                  "path": str(py_path),
                  "banner": banner or "",
                  "module_docstring": module_doc or "",
                  "defs": defs_out,
              }

          def main(argv: List[str]) -> int:
              root_arg: Optional[str] = None
              out_arg: Optional[str] = None
              it = iter(argv)
              for a in it:
                  if a == "--root":
                      root_arg = next(it, None)
                  elif a == "--out":
                      out_arg = next(it, None)

              root = Path(root_arg) if root_arg else Path.cwd()
              if not root.exists():
                  print(f"[ERROR] Racine invalide: {root}", file=sys.stderr)
                  return 2

              out_path = Path(out_arg) if out_arg else root / DEFAULT_OUT
              out_path.parent.mkdir(parents=True, exist_ok=True)

              all_files = iter_files(root)
              py_files = [p for p in all_files if p.suffix == ".py"]

              snapshot: Dict[str, Any] = {
                  "snapshot": {
                      "project": root.name,
                      "root": str(root.resolve()),
                      "generated_at": datetime.utcnow().isoformat(timespec="seconds") + "Z",
                      "python": sys.version.split()[0],
                      "platform": platform.platform(),
                      "files_count": len(all_files),
                      "py_files_count": len(py_files),
                      "ignored_dirs": sorted(list(IGNORED_DIRS)),
                  },
                  "tree": ascii_tree(root),
                  "files": [],
              }

              for py in py_files:
                  item = extract_python_file(py)
                  try:
                      item["relpath"] = str(py.relative_to(root)).replace(os.sep, "/")
                  except Exception:
                      item["relpath"] = str(py)
                  snapshot["files"].append(item)

              with out_path.open("w", encoding="utf-8") as f:
                  yaml.dump(snapshot, f, Dumper=_LiteralDumper, sort_keys=False, allow_unicode=True, width=100)

              print(f"[OK] Contexte écrit → {out_path}")
              return 0

          if __name__ == "__main__":
              raise SystemExit(main(sys.argv[1:]))
          PY

      - name: Run snapshot
        run: |
          python scripts/context_snapshot.py --root . --out .archcode/context_snapshot.yaml
          test -f .archcode/context_snapshot.yaml || (echo "Fichier non généré !" && exit 1)

      - name: Upload context as artifact
        uses: actions/upload-artifact@v4
        with:
          name: context_snapshot
          path: .archcode/context_snapshot.yaml
          if-no-files-found: error

      - name: Debug output
        run: |
          echo "=== Listing .archcode directory ==="
          ls -la .archcode || echo ".archcode does not exist"
          echo "=== Full tree ==="
          find . -type f | sort

      - name: Commit snapshot to main
        run: |
          set -e
          git config user.name "archcode-bot"
          git config user.email "archcode-bot@users.noreply.github.com"
          # attempt safe push to main; if branch protected push will fail but artifact is available
          git checkout main
          git pull --rebase origin main || true
          git add -f .archcode/context_snapshot.yaml scripts/context_snapshot.py
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore(context): refresh context_snapshot.yaml"
            git push origin main || echo "::warning::Push vers main refusé (branche protégée). Le fichier reste disponible en Artifacts."
          fi
